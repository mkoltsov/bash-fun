500  cat /etc/shells
  501  cat /etc/passwd
  502  cat /etc/passwd | grep bash
  503  zsh
  504  echo $-
  505  echo $HISTFILE
  506  tail -n 10 $HISTFILE
  507  dirs
  508  popd
  509  cd ..
  510  dirs
  511  popd
  512  pushd
  513  pushd /
  514  popd
  515  dirs
  bash -x script.sh
  
set -x      # activate debugging from here
w
set +x      # stop debugging from here
which -a script_name
whereis script_name
locate script_name
If you don't want to start a new shell but execute the script in the current shell, you source it:
source script_name.sh
source = .
The Bash source built-in is a synonym for the Bourne shell . (dot) command.
The script does not need execute permission in this case. Commands are executed in the current shell context,
so any changes made to your environment will be visible when the script finishes execution:
# Create a timestamp in a logfile.
date >> $LOGFILE
echo backup succeeded >> $LOGFILE
echo '$date'
$date
$(command)

or like this using backticks:

`command`

Bash performs the expansion by executing COMMAND and replacing the command substitution with the standard output of the command, with any trailing newlines deleted. Embedded newlines are not deleted, but they may be removed during word splitting.

franky ~> echo `date`
Thu Feb 6 10:06:20 CET 2003

echo $(( 1000-10 ))
990
bash-3.2$ echo $[ 1000-10]
990

grep -n root /etc/passwd
grep -v bash /etc/passwd | grep -v nologin

grep -c root /etc/passwd
3

grep -c '*' /etc/passwd

ls -ld [[:digit:]]*

ls -ld [[:upper:]]*

grep -c '.' /etc/passwd == wc -l /etc/passwd

sed -n '/root/p' /etc/passwd -- inclusive

sed '/root/d' /etc/passwd -- exclusive

sed '3,$d' /etc/passwd - 3rd line only

ls -l | awk '{ print $1 $4}'

ls -ldh * | grep -v total | awk '{ print "Size is " $5 " bytes for " $9 }'

df -h | sort -rnk 5 | head -3 | awk '{ print "Partition " $6 "\t: " $5 " full!" }'

df -h | awk '/dev\/hd/ { print $6 "\t: " $5 }'

ls -l | awk '/\<(a|x).*\.conf$/ { print $9 }'

ls -l | awk 'BEGIN { print "Files found:\n" } /\<[a|x].*\.conf$/ { print $9 }'

ls -l | awk '/\<[a|x].*\.conf$/ { print $9 } END { print "Can I do anything else for you, mistress?" }'

df -h | awk -f diskrep.awk

awk 'BEGIN { FS=":" } { print $1 "\t" $5 }' /etc/passwd

awk '{ print $1, $2}' test

awk 'BEGIN { OFS=";" ; ORS="\n-->\n" } { print $1,$2}' test

awk -f processed.awk test

echo "This scripts checks the existence of the messages file."
echo "Checking..."
if [ -f /var/log/messages ]
  then
    echo "/var/log/messages exists."
fi
echo
echo "...done."

The ? variable holds the exit status of the previously executed command (the most recently completed foreground process).

The following example shows a simple test:

 if [ $? -eq 0 ]
  then echo 'That was a good job!'
 fi

if ! grep $USER /etc/passwd
  then echo "your user account is not managed locally"; fi 

echo $?

grep $USER /etc/passwd

if [ $? -ne 0 ] ; then echo "not a local account" ; fi


[ "$(whoami)" != 'root' ] && ( echo you are using a non-privileged account; exit 1 )

num=`wc -l work.txt`

if [ "$num" -gt "150" ]
 then echo ; echo "you've worked hard enough for today."
 echo ;
fi  

if [[ "$gender" == f* ]]
 then echo "Pleasure to meet you, Madame."; fi


test "$(whoami)" != 'root' && (echo you are using a non-privileged account; exit 1)

if [[ "$gender" == "f*" ]]
then echo "Pleasure to meet you, Madame."
 else echo "How come the lady hasn't got a drink yet?"
fi

  [] vs. [[]]
  
Contrary to [, [[ prevents word splitting of variable values. So, if VAR="var with spaces", you do not need to double quote $VAR in a test - eventhough using quotes remains a good habit. Also, [[ prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames. Using [[, == and != interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance: [[ "value" == val* ]]

if ! grep ^$USER /etc/passwd 1> /dev/null
 then echo "your user account is not managed locally"
 else echo "your account is managed from the local /etc/passwd file"
fi

 read pupa
 echo $pupa

 read
 echo $REPLY

 ls -l /dev/std*
 ls -l /dev/fd/[0-2]
 
 touch /Users/mkoltsov/dev/learn/bash-fun/testfile | at +1 minute
 touch /Users/mkoltsov/dev/learn/bash-fun/testfile | at 1430

 crontab -l


ls -l * 2> /var/tmp/unaccessible-in-spool

ls -l * > /var/tmp/spoollist 2>&1

ls -l * 2 >& 1 > /var/tmp/spoollist

exec 4> result.txt

filter body.txt | cat header.txt /dev/fd/0 footer.txt >& 4

cat result.txt

ls *.empty
ls *.empty > list

for i in `cat list`; do cp "$i" "$i".bak1 ; done
for i in `ls /sbin`; do file /sbin/$i | grep ASCII; done


for i in $PATHNAME/*; do
  echo $i
done


#!/bin/bash

# This script opens 4 terminal windows.

i="0"

while [ $i -lt 4 ]
do
  xterm &
  i=$[$i+1]
done

# This script copies files from my homedirectory into the webserver directory.
# (use scp and SSH keys for a remote directory)
# A new directory is created every hour.

PICSDIR=/home/carol/pics
WEBDIR=/var/www/carol/webcam

while true; do 
  DATE=`date +%Y%m%d`
  HOUR=`date +%H`
  mkdir $WEBDIR/"$DATE"
  
  while [ $HOUR -ne "00" ]; do 
    DESTDIR=$WEBDIR/"$DATE"/"$HOUR"
    mkdir "$DESTDIR"
    mv $PICDIR/*.jpg "$DESTDIR"/
    sleep 3600
    HOUR=`date +%H`
  done
done

# This generates a file every 5 minutes

while true; do
touch pic-`date +%s`.jpg
sleep 1
echo "pushed one more"
done

while true; do curl 127.0.0.1; done

declare -i VARIABLE=12
declare -p VARIABLE

-a  Variable is an array.
-f  Use function names only.
-i  The variable is to be treated as an integer; arithmetic evaluation is performed when the variable is assigned a value (see Section 3.4.6).
-p  Display the attributes and values of each variable. When -p is used, additional options are ignored.
-r  Make variables read-only. These variables cannot then be assigned values by subsequent assignment statements, nor can they be unset.
-t  Give each variable the trace attribute.
-x  Mark each variable for export to subsequent commands via the environment.

 readonly TUX=penguinpower

 declare -a ARRAYNAME
 ARRAY=(value1 value2 ... valueN)
 echo ${ARRAY[*]}
 echo ${ARRAY[0]}
 ARRAY[0]=chef
 unset ARRAY[1]
 unset ARRAY
 echo ${#SHELL}
 ARRAY=(one two three)
 echo ${#ARRAY}
 echo ${TEST:-test}
 [ -z "${SHIT:-}" ] && SHIT=80

 if [ -z "${COLUMNS:-}" ]; then
  COLUMNS=80
fi
echo ${TEST2:=$TEST}
export STRING="thisisaverylongname"
echo ${STRING:4}
 echo ${STRING:6:5}
 echo ${ARRAY[*]#one}
 echo ${ARRAY[*]#t}
 echo ${ARRAY[*]#t*}
 echo ${ARRAY[*]##t*}

 echo $STRING
thisisaverylongname

[bob in ~] echo ${STRING%name}
thisisaverylong

if [ $RETVAL -eq 0 ]; then
  <start the daemon>

[ $RETVAL = 0 ] && touch /var/lock/subsys/amd

exit $RETVAL

test ()
{
echo "Positional parameter 1 in the function is $1."
RETURN_VALUE=$?
echo "The exit code of this function is $RETURN_VALUE."
}

test other_param

You could make your own /etc/functions file that contains all functions that you use regularly on your system, in different scripts. Just put the line

. /etc/functions

#####

pathmunge () {
        if ! echo $PATH | /bin/egrep -q "(^|:)$1($|:)" ; then
           if [ "$2" = "after" ] ; then
              PATH=$PATH:$1
           else
              PATH=$1:$PATH
           fi
        fi
}

# Path manipulation
if [ `id -u` = 0 ]; then
        pathmunge /sbin
        pathmunge /usr/sbin
        pathmunge /usr/local/sbin
fi

pathmunge /usr/X11R6/bin after

unset pathmunge

man -k signal | grep list

kill -l

Standard key combination  Meaning
Ctrl+C  The interrupt signal, sends SIGINT to the job running in the foreground.
Ctrl+Y  The delayed suspend character. Causes a running process to be stopped when it attempts to read input from the terminal. Control is returned to the shell, the user can foreground, background or kill the process. Delayed suspend is only available on operating systems supporting this feature.
Ctrl+Z  The suspend signal, sends a SIGTSTP to a running program, thus stopping it and returning control to the shell.

Common kill signals

Signal name Signal value  Effect
SIGHUP  1 Hangup
SIGINT  2 Interrupt from keyboard
SIGKILL 9 Kill signal
SIGTERM 15  Termination signal
SIGSTOP 17,19,23  Stop the process

maud: ~> ps -ef | grep stuck_process
maud    5607   2214  0 20:05 pts/5    00:00:02 stuck_process

maud: ~> kill -9 5607

maud: ~> ps -ef | grep stuck_process
maud    5614    2214 0 20:15 pts/5    00:00:00 grep stuck_process
[1]+ Killed   stuck_process


declare -t VARIABLE=value

trap "echo VARIABLE is being used here." DEBUG

# rest of the script


#!/bin/bash

LOCKFILE=/var/lock/makewhatis.lock

# Previous makewhatis should execute successfully:

[ -f $LOCKFILE ] && exit 0

# Upon exit, remove lockfile.

trap "{ rm -f $LOCKFILE ; exit 255; }" EXIT

touch $LOCKFILE
makewhatis -u -w
exit 0

Command Meaning
> Redirect output
>>  Append to file
< Redirect input
<<  "Here" document (redirect input)
| Pipe output
& Run process in background.
; Separate commands on same line
* Match any character(s) in filename
? Match single character in filename
[ ] Match any characters enclosed
( ) Execute in subshell
` ` Substitute output of enclosed command
" " Partial quote (allows variable and command expansion)
' ' Full quote (no expansion)
\ Quote following character
$var  Use value for variable
$$  Process id
$0  Command name
$n  nth argument (n from 0 to 9)
# Begin comment
bg  Background execution
break Break from loop statements
cd  Change directories
continue  Resume a program loop
echo  Display output
eval  Evaluate arguments
exec  Execute a new shell
fg  Foreground execution
jobs  Show active jobs
kill  Terminate running jobs
newgrp  Change to a new group
shift Shift positional parameters
stop  Suspend a background job
suspend Suspend a foreground job
time  Time a command
umask Set or list file permissions
unset Erase variable or function definitions
wait  Wait for a background job to finish

