500  cat /etc/shells
  501  cat /etc/passwd
  502  cat /etc/passwd | grep bash
  503  zsh
  504  echo $-
  505  echo $HISTFILE
  506  tail -n 10 $HISTFILE
  507  dirs
  508  popd
  509  cd ..
  510  dirs
  511  popd
  512  pushd
  513  pushd /
  514  popd
  515  dirs
  bash -x script.sh
  
set -x      # activate debugging from here
w
set +x      # stop debugging from here
which -a script_name
whereis script_name
locate script_name
If you don't want to start a new shell but execute the script in the current shell, you source it:
source script_name.sh
source = .
The Bash source built-in is a synonym for the Bourne shell . (dot) command.
The script does not need execute permission in this case. Commands are executed in the current shell context,
so any changes made to your environment will be visible when the script finishes execution:
# Create a timestamp in a logfile.
date >> $LOGFILE
echo backup succeeded >> $LOGFILE
echo '$date'
$date
$(command)

or like this using backticks:

`command`

Bash performs the expansion by executing COMMAND and replacing the command substitution with the standard output of the command, with any trailing newlines deleted. Embedded newlines are not deleted, but they may be removed during word splitting.

franky ~> echo `date`
Thu Feb 6 10:06:20 CET 2003

echo $(( 1000-10 ))
990
bash-3.2$ echo $[ 1000-10]
990

grep -n root /etc/passwd
grep -v bash /etc/passwd | grep -v nologin

grep -c root /etc/passwd
3

grep -c '*' /etc/passwd

ls -ld [[:digit:]]*

ls -ld [[:upper:]]*

grep -c '.' /etc/passwd == wc -l /etc/passwd

sed -n '/root/p' /etc/passwd -- inclusive

sed '/root/d' /etc/passwd -- exclusive

sed '3,$d' /etc/passwd - 3rd line only

ls -l | awk '{ print $1 $4}'

ls -ldh * | grep -v total | awk '{ print "Size is " $5 " bytes for " $9 }'

df -h | sort -rnk 5 | head -3 | awk '{ print "Partition " $6 "\t: " $5 " full!" }'

df -h | awk '/dev\/hd/ { print $6 "\t: " $5 }'

ls -l | awk '/\<(a|x).*\.conf$/ { print $9 }'

ls -l | awk 'BEGIN { print "Files found:\n" } /\<[a|x].*\.conf$/ { print $9 }'

ls -l | awk '/\<[a|x].*\.conf$/ { print $9 } END { print "Can I do anything else for you, mistress?" }'

df -h | awk -f diskrep.awk

awk 'BEGIN { FS=":" } { print $1 "\t" $5 }' /etc/passwd

awk '{ print $1, $2}' test

awk 'BEGIN { OFS=";" ; ORS="\n-->\n" } { print $1,$2}' test

awk -f processed.awk test

echo "This scripts checks the existence of the messages file."
echo "Checking..."
if [ -f /var/log/messages ]
  then
    echo "/var/log/messages exists."
fi
echo
echo "...done."

The ? variable holds the exit status of the previously executed command (the most recently completed foreground process).

The following example shows a simple test:

 if [ $? -eq 0 ]
  then echo 'That was a good job!'
 fi

if ! grep $USER /etc/passwd
  then echo "your user account is not managed locally"; fi 

echo $?

grep $USER /etc/passwd

if [ $? -ne 0 ] ; then echo "not a local account" ; fi


[ "$(whoami)" != 'root' ] && ( echo you are using a non-privileged account; exit 1 )

num=`wc -l work.txt`

if [ "$num" -gt "150" ]
 then echo ; echo "you've worked hard enough for today."
 echo ;
fi  

if [[ "$gender" == f* ]]
 then echo "Pleasure to meet you, Madame."; fi


test "$(whoami)" != 'root' && (echo you are using a non-privileged account; exit 1)

if [[ "$gender" == "f*" ]]
then echo "Pleasure to meet you, Madame."
 else echo "How come the lady hasn't got a drink yet?"
fi

  [] vs. [[]]
  
Contrary to [, [[ prevents word splitting of variable values. So, if VAR="var with spaces", you do not need to double quote $VAR in a test - eventhough using quotes remains a good habit. Also, [[ prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames. Using [[, == and != interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance: [[ "value" == val* ]]

if ! grep ^$USER /etc/passwd 1> /dev/null
 then echo "your user account is not managed locally"
 else echo "your account is managed from the local /etc/passwd file"
fi

 read pupa
 echo $pupa

 read
 echo $REPLY

 ls -l /dev/std*
 ls -l /dev/fd/[0-2]
 
 touch /Users/mkoltsov/dev/learn/bash-fun/testfile | at +1 minute
 touch /Users/mkoltsov/dev/learn/bash-fun/testfile | at 1430

 crontab -l


ls -l * 2> /var/tmp/unaccessible-in-spool

ls -l * > /var/tmp/spoollist 2>&1

ls -l * 2 >& 1 > /var/tmp/spoollist

exec 4> result.txt

filter body.txt | cat header.txt /dev/fd/0 footer.txt >& 4

cat result.txt

ls *.empty
ls *.empty > list

for i in `cat list`; do cp "$i" "$i".bak1 ; done
for i in `ls /sbin`; do file /sbin/$i | grep ASCII; done


for i in $PATHNAME/*; do
  echo $i
done


#!/bin/bash

# This script opens 4 terminal windows.

i="0"

while [ $i -lt 4 ]
do
  xterm &
  i=$[$i+1]
done

# This script copies files from my homedirectory into the webserver directory.
# (use scp and SSH keys for a remote directory)
# A new directory is created every hour.

PICSDIR=/home/carol/pics
WEBDIR=/var/www/carol/webcam

while true; do 
  DATE=`date +%Y%m%d`
  HOUR=`date +%H`
  mkdir $WEBDIR/"$DATE"
  
  while [ $HOUR -ne "00" ]; do 
    DESTDIR=$WEBDIR/"$DATE"/"$HOUR"
    mkdir "$DESTDIR"
    mv $PICDIR/*.jpg "$DESTDIR"/
    sleep 3600
    HOUR=`date +%H`
  done
done

# This generates a file every 5 minutes

while true; do
touch pic-`date +%s`.jpg
sleep 1
echo "pushed one more"
done

while true; do curl 127.0.0.1; done

declare -i VARIABLE=12
declare -p VARIABLE

-a  Variable is an array.
-f  Use function names only.
-i  The variable is to be treated as an integer; arithmetic evaluation is performed when the variable is assigned a value (see Section 3.4.6).
-p  Display the attributes and values of each variable. When -p is used, additional options are ignored.
-r  Make variables read-only. These variables cannot then be assigned values by subsequent assignment statements, nor can they be unset.
-t  Give each variable the trace attribute.
-x  Mark each variable for export to subsequent commands via the environment.

 readonly TUX=penguinpower

 declare -a ARRAYNAME
 ARRAY=(value1 value2 ... valueN)
 echo ${ARRAY[*]}
 echo ${ARRAY[0]}
 ARRAY[0]=chef
 unset ARRAY[1]
 unset ARRAY
 echo ${#SHELL}
 ARRAY=(one two three)
 echo ${#ARRAY}
 echo ${TEST:-test}
 [ -z "${SHIT:-}" ] && SHIT=80

 if [ -z "${COLUMNS:-}" ]; then
  COLUMNS=80
fi
echo ${TEST2:=$TEST}
export STRING="thisisaverylongname"
echo ${STRING:4}
 echo ${STRING:6:5}
 echo ${ARRAY[*]#one}
 echo ${ARRAY[*]#t}
 echo ${ARRAY[*]#t*}
 echo ${ARRAY[*]##t*}

 echo $STRING
thisisaverylongname

[bob in ~] echo ${STRING%name}
thisisaverylong
