500  cat /etc/shells
  501  cat /etc/passwd
  502  cat /etc/passwd | grep bash
  503  zsh
  504  echo $-
  505  echo $HISTFILE
  506  tail -n 10 $HISTFILE
  507  dirs
  508  popd
  509  cd ..
  510  dirs
  511  popd
  512  pushd
  513  pushd /
  514  popd
  515  dirs
  bash -x script.sh
  
set -x      # activate debugging from here
w
set +x      # stop debugging from here
which -a script_name
whereis script_name
locate script_name
If you don't want to start a new shell but execute the script in the current shell, you source it:
source script_name.sh
source = .
The Bash source built-in is a synonym for the Bourne shell . (dot) command.
The script does not need execute permission in this case. Commands are executed in the current shell context,
so any changes made to your environment will be visible when the script finishes execution:
# Create a timestamp in a logfile.
date >> $LOGFILE
echo backup succeeded >> $LOGFILE
echo '$date'
$date
$(command)

or like this using backticks:

`command`

Bash performs the expansion by executing COMMAND and replacing the command substitution with the standard output of the command, with any trailing newlines deleted. Embedded newlines are not deleted, but they may be removed during word splitting.

franky ~> echo `date`
Thu Feb 6 10:06:20 CET 2003

echo $(( 1000-10 ))
990
bash-3.2$ echo $[ 1000-10]
990

grep -n root /etc/passwd
grep -v bash /etc/passwd | grep -v nologin

grep -c root /etc/passwd
3

grep -c '*' /etc/passwd

ls -ld [[:digit:]]*

ls -ld [[:upper:]]*

grep -c '.' /etc/passwd == wc -l /etc/passwd

sed -n '/root/p' /etc/passwd -- inclusive

sed '/root/d' /etc/passwd -- exclusive
